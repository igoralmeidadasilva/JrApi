# Jr.API
Bem-vindo √† **Jr.Api**! Este projeto foi originalmente desenvolvido como parte de um teste t√©cnico para o n√≠vel Junior e, com o tempo, evoluiu para um espa√ßo onde pratico boas pr√°ticas de programa√ß√£o. A Jr.Api √© uma API RESTful que permite o gerenciamento de usu√°rios, oferecendo opera√ß√µes completas de CRUD (Create, Read, Update, Delete) em um banco de dados SQLite. O objetivo √© aplicar conceitos como arquitetura limpa, domain driven design, boas pr√°ticas de c√≥digo, e garantir uma API eficiente e f√°cil de usar. Espero que gostem! üòÑ

## ‚úî Funcionalidades Implementadas
* CRUD (Create, Read, Update e Delete) em uma tabela de usu√°rios cadastrados.

## üèÉ‚Äç‚ôÇÔ∏è Pr√°ticas Utilizadas
### REST API
A Jr.Api utiliza dos princ√≠pios de uma REST API (Representational State Transfer) que √© um padr√£o arquitetural criado por **Roy Fielding** em sua tese de doutorado em 2000. Este estilo de arquitetura √© amplamente utilizado no desenvolvimento de servi√ßos web, permitindo a comunica√ß√£o entre sistemas atrav√©s de requisi√ß√µes HTTP utilizando verbos como GET, POST, PUT e DELETE.

Aqui eu optei por seguir a risca o **O Modelo de Maturidade de Richardson**, que √© uma maneira de avaliar a conformidade de uma API com os princ√≠pios REST. O modelo √© dividido em quatro n√≠veis de maturidade:

N√≠vel 0 - The Swamp of POX: As APIs no n√≠vel 0 utilizam HTTP apenas como um transporte, sem utilizar os recursos ou verbos HTTP de maneira correta. Muitas vezes, as requisi√ß√µes s√£o tratadas como chamadas a um servi√ßo remoto (RPC).

N√≠vel 1 - Recursos: No n√≠vel 1, a API j√° trata elementos do sistema como recursos. Cada recurso possui uma URI pr√≥pria, mas ainda n√£o se aproveita plenamente dos verbos HTTP.

N√≠vel 2 - Verbos HTTP: APIs de n√≠vel 2 come√ßam a utilizar corretamente os verbos HTTP (GET, POST, PUT, DELETE), melhorando a sem√¢ntica das opera√ß√µes e se aproximando do estilo RESTful.

N√≠vel 3 - HATEOAS: O n√≠vel mais alto de maturidade √© atingido quando a API fornece hiperm√≠dia (HATEOAS) como parte das respostas, permitindo que o cliente navegue pelos recursos de forma din√¢mica, tornando a intera√ß√£o com a API autodescritiva e mais robusta.

**Refer√™ncias**: [1](https://www.redhat.com/pt-br/topics/api/what-is-a-rest-api), [2](https://www.sensedia.com.br/pillar/historia-das-apis#:~:text=REST%20foi%20como%20um%20sopro,recursos%20web%20de%20forma%20harmoniosa.) e [3](https://rivaildojunior.medium.com/modelo-de-maturidade-de-richardson-para-apis-rest-8845f93b288)

### Domain Driven Design
A Jr.Api adota os princ√≠pios do Domain Driven Design (DDD) para organizar a l√≥gica de neg√≥cio de maneira eficiente e escal√°vel. DDD foca na cria√ß√£o de um modelo de dom√≠nio robusto, onde as regras e opera√ß√µes da aplica√ß√£o s√£o centralizadas. Isso facilita o entendimento e a evolu√ß√£o do c√≥digo, permitindo que os conceitos do neg√≥cio sejam representados de forma clara e concisa.

**Refer√™ncias**: [1](https://medium.com/beelabacademy/implementando-na-pr%C3%A1tica-rest-api-com-conceitos-de-ddd-net-2160291a44b7), [2](https://www.macoratti.net/20/07/aspnc_ucddd1.htm), [3](https://medium.com/beelabacademy/implementando-na-pr%C3%A1tica-rest-api-com-conceitos-de-ddd-net-2160291a44b7) e [4](https://www.milanjovanovic.tech/blog/value-objects-in-dotnet-ddd-fundamentals)

### Clean Architecture 
A estrutura do projeto segue os padr√µes de Clean Architecture, que tem como objetivo separar as responsabilidades da aplica√ß√£o em camadas independentes. Isso promove um c√≥digo desacoplado e f√°cil de manter, facilitando a testabilidade e possibilitando a troca de frameworks e tecnologias sem impactar as regras de neg√≥cio. Essa abordagem garante que as decis√µes de implementa√ß√£o fiquem isoladas das regras do dom√≠nio. DDD e Clean Architecture apresentam uma rela√ß√£o bem pr√≥xima com a Clean Architecture utilizando de muitos principios do DDD na sua camada inferior.

**Refer√™ncias**: [1](https://www.youtube.com/watch?v=1Lcr2c3MVF4&feature=youtu.be), [2](https://www.milanjovanovic.tech/blog/clean-architecture-folder-structure) e [3](https://www.linkedin.com/pulse/como-estruturo-pastas-utilizando-o-clean-architecture-william-g-silva/)


### CQRS
A Jr.Api implementa o padr√£o CQRS(Command Query Responsibility Segregation) para separar as opera√ß√µes de leitura e escrita, garantindo uma melhor organiza√ß√£o e clareza na execu√ß√£o das opera√ß√µes. Com o CQRS, os comandos (opera√ß√µes de escrita) e as consultas (opera√ß√µes de leitura) s√£o tratados de maneira independente, o que possibilita uma otimiza√ß√£o mais granular e facilita a evolu√ß√£o da API sem comprometer a integridade do c√≥digo.

**Refer√™ncias**: [1](https://codewithmukesh.com/blog/cqrs-and-mediatr-in-aspnet-core/) e [2](https://www.milanjovanovic.tech/blog/cqrs-pattern-with-mediatr)

### Result Pattern
A Jr.Api utiliza o Result Pattern para padronizar os retornos das opera√ß√µes, garantindo que os m√©todos retornem um objeto de resultado em vez de lan√ßar exce√ß√µes diretamente. Essa abordagem permite um tratamento centralizado e mais eficiente dos erros e sucessos nas opera√ß√µes, aumentando a robustez e previsibilidade da API. Para isso, foi desenvolvida uma biblioteca personalizada que facilita a manipula√ß√£o de respostas, contendo informa√ß√µes detalhadas sobre sucesso, falha, e poss√≠veis mensagens de erro.


**Refer√™ncias**: [1](https://www.milanjovanovic.tech/blog/functional-error-handling-in-dotnet-with-the-result-pattern), [2](https://www.milanjovanovic.tech/blog/functional-error-handling-in-dotnet-with-the-result-pattern), [3](https://code-maze.com/aspnetcore-result-pattern/), [4](https://medium.com/@wgyxxbf/result-pattern-a01729f42f8c) e [5](https://github.com/altmann/FluentResults)


### Soft Delete
A API implementa a estrat√©gia de Soft Delete no banco de dados, o que significa que, ao inv√©s de excluir permanentemente os registros, eles s√£o marcados como exclu√≠dos. Isso permite que os dados sejam recuperados em caso de exclus√£o acidental ou que sejam mantidos para auditoria e hist√≥rico. Para isso, um campo adicional √© adicionado √†s tabelas para indicar o status de exclus√£o dos registros, e filtros globais no Entity Framework Core garantem que registros exclu√≠dos n√£o sejam retornados nas consultas regulares.

**Refer√™ncias**: [1](https://www.milanjovanovic.tech/blog/implementing-soft-delete-with-ef-core)

### Repository Pattern
A Jr.Api segue o Repository Pattern para desacoplar a l√≥gica de acesso aos dados das camadas superiores. O projeto utiliza o Entity Framework Core para implementar dois tipos de reposit√≥rios: ReadOnlyRepository e PersistenceRepository.

* ReadOnlyRepository: Respons√°vel por consultas de leitura, onde se busca desempenho e simplicidade. Al√©m de usar o Entity Framework Core, este reposit√≥rio pode utilizar Dapper para consultas mais r√°pidas e otimizadas, especialmente em cen√°rios onde a performance √© cr√≠tica.

* PersistenceRepository: Utilizado para opera√ß√µes que modificam o estado da aplica√ß√£o, como inser√ß√µes, atualiza√ß√µes e exclus√µes. Este reposit√≥rio gerencia o ciclo de vida das transa√ß√µes no banco de dados, garantindo consist√™ncia e integridade dos dados.

A separa√ß√£o desses reposit√≥rios permite uma arquitetura mais flex√≠vel e otimizada, onde as opera√ß√µes de leitura e escrita s√£o tratadas de forma independente, permitindo uma melhor otimiza√ß√£o e desempenho da API.

**Refer√™ncias**: [1](https://learn.microsoft.com/pt-br/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/infrastructure-persistence-layer-implementation-entity-framework-core), [2](https://codewithmukesh.com/blog/repository-pattern-in-aspnet-core/) e [3](https://blog.balta.io/dapper-unit-of-work-repository-pattern/)

### Unit Of Work
A Jr.Api adota o padr√£o Unit of Work para gerenciar as transa√ß√µes no contexto do banco de dados. Esse padr√£o garante que todas as opera√ß√µes realizadas em uma unidade de trabalho (como m√∫ltiplas opera√ß√µes de escrita) sejam tratadas como uma √∫nica transa√ß√£o. Se todas as opera√ß√µes forem bem-sucedidas, as altera√ß√µes s√£o persistidas no banco de dados; caso contr√°rio, elas s√£o revertidas. Esse padr√£o oferece maior controle e seguran√ßa, evitando inconsist√™ncias nos dados e garantindo que as modifica√ß√µes sejam aplicadas de forma at√¥mica. A implementa√ß√£o do Unit of Work √© feita sobre o Entity Framework Core, o que facilita o gerenciamento das transa√ß√µes, al√©m de proporcionar uma camada adicional de abstra√ß√£o para a manipula√ß√£o de dados.

**Refer√™ncias**: [1](https://blog.balta.io/dapper-unit-of-work-repository-pattern/)

## Versionamento da API

O versionamento de uma API REST √© uma pr√°tica essencial para garantir que mudan√ßas e melhorias possam ser introduzidas sem impactar negativamente os clientes que dependem de vers√µes anteriores da API. No **Jr.Api**, seguimos as melhores pr√°ticas de versionamento para garantir compatibilidade e estabilidade ao longo do tempo.

### Estrat√©gias de Versionamento Utilizadas

No **Jr.Api**, o versionamento √© feito atrav√©s da URL. Dessa forma, cada nova vers√£o da API √© acessada por meio de um caminho distinto, como mostrado abaixo:

- `/api/v1/users`: Acessa a vers√£o 1 da API para recursos relacionados a usu√°rios.
- `/api/v2/users`: Acessa a vers√£o 2, com poss√≠veis mudan√ßas ou adi√ß√µes.

Essa abordagem garante que clientes que utilizam a vers√£o 1 da API possam continuar funcionando mesmo ap√≥s a libera√ß√£o de vers√µes mais recentes, sem a necessidade de ajustes imediatos.

Al√©m disso, o versionamento de API permite a introdu√ß√£o de novas funcionalidades ou mudan√ßas na estrutura de dados, mantendo a compatibilidade com clientes que ainda dependem de vers√µes anteriores.

**Refer√™ncias**: [1](https://dev.to/iamrule/comprehensive-guide-to-api-versioning-in-net-8-1i9j) e [2](https://github.com/dotnet/aspnet-api-versioning/tree/main)

---

## Documenta√ß√£o via Swagger

A documenta√ß√£o √© um aspecto fundamental no desenvolvimento de APIs, garantindo que os consumidores possam entender e interagir corretamente com os endpoints dispon√≠veis. No **Jr.Api**, utilizamos o **Swagger** para fornecer uma documenta√ß√£o clara e interativa.

O **Swagger** oferece uma interface gr√°fica onde os desenvolvedores podem visualizar e testar todos os endpoints da API diretamente pelo navegador, facilitando o processo de desenvolvimento e integra√ß√£o.

### Acessando a Documenta√ß√£o

A documenta√ß√£o gerada pelo Swagger pode ser acessada diretamente ao rodar o projeto. Para visualizar a interface, basta acessar o seguinte endere√ßo no seu navegador:

```
https://localhost:5230/swagger/index.html
```

Na interface do Swagger, voc√™ encontrar√° informa√ß√µes detalhadas sobre:

- Todos os endpoints dispon√≠veis (GET, POST, PUT, DELETE).
- Par√¢metros necess√°rios para cada requisi√ß√£o.
- Estrutura de resposta e poss√≠veis c√≥digos de status HTTP retornados.
- Exemplos de uso e resultados esperados.

A documenta√ß√£o via Swagger facilita o entendimento da API, tornando-a mais acess√≠vel para desenvolvedores e usu√°rios.

**Refer√™ncias**: [1](https://medium.com/@celery_liu/asp-net-core-web-api-with-swagger-api-versioning-for-dotnet-8-c8ce2fd7808c) e [2](https://github.com/renatogroffe/ASPNETCore7-REST_API-Swagger-Versioning-Dockerfile_ContagemAcessos)

---

## üéØ Pr√©-Requisitos
Antes de iniciar a configura√ß√£o e execu√ß√£o da JrApi, certifique-se de que os seguintes pr√©-requisitos est√£o atendidos:

* [.NET 8 SDK](https://dotnet.microsoft.com/en-us/download/dotnet/8.0)
* [Visual Studio](https://visualstudio.microsoft.com/pt-br/downloads/) ou outra IDE da sua prefer√™ncia.

---

## üé• Executando o Projeto

### Ambientes

#### Desenvolvimento
Para rodar o projeto em ambiente de desenvolvimento, siga os seguintes passos:

1. Clone o reposit√≥rio: Clone o projeto para sua m√°quina local usando o comando:

```console
git clone https://github.com/igoralmeidadasilva/JrApi.git
```

2. Instale as depend√™ncias: Navegue at√© a pasta do projeto e execute o comando abaixo para restaurar os pacotes NuGe

```console
cd ./src
dotnet restore
```

3. Dentro dos arquivo  [appsettings.json](src\JrApi.Presentation\appsettings.json) e [appsettings.Development.json](src\JrApi.Presentation\appsettings.Development.json) e configure as vari√°veis de ambiente (como a string de conex√£o do banco de dados).

4. Executar o projeto: Utilize o seguinte comando para iniciar o servidor em modo de desenvolvimento ou se voc√™ estiver usando as IDEs Visual Studio ou Visual Studio Code basta pressionar f5:

```console
dotnet run --launch-profile "Development"
```

5. Acessar a API: A API estar√° dispon√≠vel em:
```console
http://localhost:5230/swagger/index.html
```

---

#### Produ√ß√£o
Ainda n√£o implementado

---

### Migra√ß√µes
O projeto utiliza o Entity Framework Core para gerenciar as migra√ß√µes do banco de dados. Para aplicar as migra√ß√µes, certifique-se de estar dentro de src/JrApi.Presentation e siga os passos abaixo:

1. Adicionar uma nova migra√ß√£o:
```console
cd ./src/JrApi.Presentation

dotnet ef migrations add NomeDaSuaMigracao --project ..\JrApi.Infrastructure\JrApi.Infrastructure.csproj
```
2. Para atualizar o banco de dados com as modifica√ß√µes temos duas alternativas:

* Atualizar o banco de dados por linha de comando, ainda dentro de src/JrApi.Presentation:
```console
dotnet ef database update
```

* Apenas execute o programa com a op√ß√£o "IsMigrationActive" igual a "true",
```json
"DatabaseSeedOptions": {
    "IsMigrationActive": true
}
```

---

### Data Seeder
Para popular o banco de dados com dados iniciais (como usu√°rios padr√£o, permiss√µes, etc.), o projeto conta com um Data Seeder. Para executar o seeder, siga as etapas abaixo:

Executar o Data Seeder: Ap√≥s a inicializa√ß√£o do projeto, o Data Seeder ser√° automaticamente executado se a op√ß√£o "IsUserSeedingActive" igual a  "true".

Dados pr√©-definidos: O seeder incluir√° dados b√°sicos para testar a API em ambiente de desenvolvimento, como usu√°rios de exemplo e roles padr√µes. Esses dados podem ser modificados diretamente no [appsettings.Development.json](src\JrApi.Presentation\appsettings.Development.json), para isso preencha da as DatabaseSeedOptions da seguinte forma:

```json
"DatabaseSeedOptions": {
    "IsUserSeedingActive": true,
    "Users": [
      {
        "CreatedOnUtc": "01/01/0001",
        "FirstName": { 
          "Value": "John"
        },
        "LastName": {
          "Value": "Doe"
        },
        "Email": {
          "Value": "john.doe@email.com"
        },
        "HashedPassword": {
          "Value": "@Teste123"
        },
        "BirthDate": "01/01/2000",
        "Role": 1,
        "Address": { // Opcional
            "Street": "Rua das flores",
            "City": "Cidade Nova",
            "District": "Bairro Resid√™ncial",
            "Number": "99",
            "State": "Esp√≠rito Santo",
            "Country": "Brasil",
            "ZipCode": "XXXXX-XXX"
        }
      }
    ]
}
```

Note que o objeto "Users" √© uma lista, por tanto fique a vontade para criar mais objetos üòÉ.

---

## ‚öô Endpoints

### User

#### Insert
URL: /api/users

M√©todo HTTP: POST

Descri√ß√£o: Cria um novo usu√°rio no sistema.

Cabe√ßalhos:
* Content-Type: application/json

##### Corpo da Requisi√ß√£o:
```json
{
  "firstName": "string",
  "lastName": "string",
  "email": "string",
  "password": "string",
  "birthDate": "0001-01-01T00:00:00.550Z",
  "address": {
    "street": "string",
    "city": "string",
    "district": "string",
    "number": 0,
    "state": "string",
    "country": "string",
    "zipCode": "string"
  }
}
```

##### Respostas:
201 Created: 
O usu√°rio foi criado com sucesso.
```json
Sem conte√∫do para resposta
```

400 Bad Request: Erros de valida√ß√£o ou dados faltantes.
```json
[
  {
    "code": "",
    "message": "",
    "type": 0
  },
  {
    "code": "",
    "message": "",
    "type": 0
  }
]
```

409 Conflict: J√° existe um email igual cadastrado.
```json
[
  {
    "code": "",
    "message": "",
    "type": 0
  },
  {
    "code": "",
    "message": "",
    "type": 0
  }
]
```

---

#### Update
URL: /api/users/{id}

M√©todo HTTP: PUT

Descri√ß√£o: Atualiza os dados de um usu√°rio existente.

Par√¢metros:
*  id (obrigat√≥rio): ID do usu√°rio.

Cabe√ßalhos:
* Content-Type: application/json

##### Corpo da Requisi√ß√£o:
```json 
{
  "firstName": "string",
  "lastName": "string",
  "birthDate": "2024-09-24T14:20:59.793Z",
  "address": {
    "street": "string",
    "city": "string",
    "district": "string",
    "number": 0,
    "state": "string",
    "country": "string",
    "zipCode": "string"
  }
}
```

##### Respostas:

204 No Content: O usu√°rio foi alterado com sucesso.
```json
Sem conte√∫do para resposta
```
```
400 Bad Request: Erros de valida√ß√£o ou dados faltantes.
```json
[
  {
    "code": "",
    "message": "",
    "type": 0
  },
  {
    "code": "",
    "message": "",
    "type": 0
  }
]
```

404 Not Found: Usu√°rio n√£o encontrado.
```json
[
  {
    "code": "",
    "message": "",
    "type": 0
  },
  {
    "code": "",
    "message": "",
    "type": 0
  }
]
```

---

#### Delete
URL: /api/users/{id}

M√©todo HTTP: DELETE

Descri√ß√£o: Remove um usu√°rio existente.

Par√¢metros:
*  id (obrigat√≥rio): ID do usu√°rio.

Cabe√ßalhos:
* Content-Type: application/json

##### Corpo da Requisi√ß√£o:
```json 
Sem conte√∫do no corpo da requisi√ß√£o
```

##### Respostas:
204 No Content: 
O usu√°rio foi removido com sucesso.
```json
Sem conte√∫do para resposta
```

404 Not Found: Usu√°rio n√£o encontrado.
```json
[
  {
    "code": "",
    "message": "",
    "type": 0
  },
  {
    "code": "",
    "message": "",
    "type": 0
  }
]
```

---

#### GetAll
URL: /api/users

M√©todo HTTP: GET

Descri√ß√£o: Busca uma lista de usu√°rios existentes.

Cabe√ßalhos:
* Content-Type: application/json

##### Corpo da Requisi√ß√£o:
```json 
Sem conte√∫do no corpo da requisi√ß√£o
```

##### Respostas:
200 Ok: A lista de usu√°rios foi cadastrado com sucesso.
```json
[
  {
    "id": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
    "createdOnUtc": "2024-09-24T14:31:03.342Z",
    "firstName": "string",
    "lastName": "string",
    "email": "string",
    "birthDate": "2024-09-24T14:31:03.342Z"
  }
]
```

---

#### GetById
URL: /api/users/{id}

M√©todo HTTP: GET

Descri√ß√£o: Busca um usu√°rio existente por ID.

Par√¢metros:
*  id (obrigat√≥rio): ID do usu√°rio.

Cabe√ßalhos:
* Content-Type: application/json

##### Corpo da Requisi√ß√£o:
```json 
Sem conte√∫do no corpo da requisi√ß√£o
```

##### Respostas:
200 Ok: A lista de usu√°rios foi cadastrado com sucesso.
```json
{
  "id": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
  "createdOnUtc": "2024-09-24T14:33:24.551Z",
  "firstName": "string",
  "lastName": "string",
  "email": "string",
  "role": "string",
  "street": "string",
  "city": "string",
  "district": "string",
  "number": 0,
  "state": "string",
  "country": "string",
  "zipCode": "string",
  "links": [
    {
      "rel": "string",
      "href": "string",
      "method": "string"
    }
  ]
}
```

404 Not Found: Usu√°rio n√£o encontrado.
```json
[
  {
    "code": "",
    "message": "",
    "type": 0
  },
  {
    "code": "",
    "message": "",
    "type": 0
  }
]
```

---

## ü§≤ Agradecimentos
Gostaria de expressar minha gratid√£o a todos que contribu√≠ram para o desenvolvimento deste projeto:

* Mentores e colegas de trabalho: Pela orienta√ß√£o e suporte ao longo da jornada, compartilhando conhecimentos valiosos sobre boas pr√°ticas de programa√ß√£o e arquitetura de software.
* Comunidade de desenvolvedores: Pelos in√∫meros recursos, tutoriais e f√≥runs que ajudaram a superar desafios t√©cnicos.
Fam√≠lia e amigos: Pelo apoio cont√≠nuo e incentivo durante a cria√ß√£o deste projeto.
* Voc√™: Por dedicar seu tempo para explorar este projeto. Espero que ele sirva de aprendizado ou inspira√ß√£o de alguma forma.
A todos, meu sincero muito obrigado!

---

## üßî Sobre Mim
Me chamo **Igor Almeida da Silva**, sou um desenvolvedor backend especializado na plataforma **.NET** e graduando em **Bacharelado em Sistemas de Informa√ß√£o pelo Instituto Federal do Esp√≠rito Santo (IFES)**, com conclus√£o prevista para dezembro de 2024.

Tenho paix√£o por boas pr√°ticas de desenvolvimento e sempre busco aprimorar minhas habilidades, aplicando conceitos como Domain-Driven Design (DDD), Clean Architecture, e CQRS. Meu foco √© criar solu√ß√µes robustas e escal√°veis, com um c√≥digo limpo e bem organizado. Al√©m disso, possuo experi√™ncia em bancos de dados SQL e NoSQL, servi√ßos de mensageria, e microservi√ßos.

A programa√ß√£o √© algo que come√ßou como curiosidade, mas rapidamente se tornou uma paix√£o. Nos meus projetos, tento aplicar tudo o que aprendo e continuo aprendendo, seja em APIs, arquitetura de software ou integra√ß√£o de sistemas complexos.

Quando n√£o estou programando, gosto de assistir filmes, jogar e estudar para continuar crescendo como profissional e pessoa.

Sinta-se √† vontade para explorar meus projetos e entrar em contato. Estou sempre aberto a feedbacks, colabora√ß√µes e novas oportunidades de aprendizado!

[![Linkedin](https://img.shields.io/badge/-Linkedin-blue?style=for-the-badge&logo=Linkedin&logoColor=white&link=https://www.linkedin.com/in/igoralmeidadasilva/)](https://www.linkedin.com/in/igoralmeidadasilva/)
[![Gmail](https://img.shields.io/badge/Gmail-D14836?style=for-the-badge&logo=gmail&logoColor=white)](mailto:igor.almeidadasilva13@gmail.com)
[![GitHub](https://img.shields.io/badge/GitHub-100000?style=for-the-badge&logo=github&logoColor=white)](https://github.com/igoralmeidadasilva)


